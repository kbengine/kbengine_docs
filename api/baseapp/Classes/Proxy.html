<html>
<head>
<title>Proxy - KBEngine base 文档</title>
<link href="../../style.css" rel="stylesheet" type="text/css">
</head>
<body>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr><td align=left style="background:#708090"> <font size=15 color=#ffffff> KBEngine </font></td></tr>
</table> <hr>
<h1>Proxy类</h1>
<p style="text-align: center;"><span class="module_h1">[<a href="../Modules/KBEngine.html" class="module_h1">KBEngine模块</a>]</span></p><p>Proxy是<a href="../Modules/KBEngine.html">KBEngine</a>模块的一部分。 <a href="#detailed_description">更多...</a></p><p></p><pre>import KBEngine</pre>
<h2>父类</h2>
<a href="Base.html">Base</a>
<br>

<h2><a href="#" onClick="obj=document.getElementById( 'functions' );vis = (obj.style.display == 'none') ? 'block' : 'none'; obj.style.display = vis; return false;" class="h2">成员函数</a></h2>
<table id="functions" cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr><td>
<span class="function_list">def <a href="#getClientType" class="function_list" >getClientType</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#giveClientTo" class="function_list" >giveClientTo</a>( self, proxy ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#streamFileToClient" class="function_list" >streamFileToClient</a>( self, resourceName, desc="", id=-1 ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#streamStringToClient" class="function_list" >streamStringToClient</a>( self, data, desc="", id=-1 ):</span>
</td></tr>

</table>

<h2><a href="#" onClick="obj=document.getElementById( 'callbacks' );vis = (obj.style.display == 'none') ? 'block' : 'none'; obj.style.display = vis; return false;" class="h2">回调函数</a></h2>
<table id="callbacks" cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr><td>
<span class="function_list">def <a href="#onClientDeath" class="function_list" >onClientDeath</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onClientGetCell" class="function_list" >onClientGetCell</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onEntitiesEnabled" class="function_list" >onEntitiesEnabled</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onGiveClientToFailure" class="function_list" >onGiveClientToFailure</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onLogOnAttempt" class="function_list" >onLogOnAttempt</a>( self, ip, port, password ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onStreamComplete" class="function_list" >onStreamComplete</a>( self, id, success ):</span>
</td></tr>

</table>

<h2><a href="#" onClick="obj=document.getElementById( 'attributes' );vis = (obj.style.display == 'none') ? 'block' : 'none'; obj.style.display = vis; return false;" class="h2">属性</a></h2>
<table id="attributes" cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><a href="#__ACCOUNT_NAME__" class="attribute_list" >__ACCOUNT_NAME__</a></td><td>&nbsp; </td></tr>

<tr valign=top><td><a href="#__ACCOUNT_PASSWORD__" class="attribute_list" >__ACCOUNT_PASSWORD__</a></td><td>&nbsp; </td></tr>

<tr valign=top><td><a href="#clientAddr" class="attribute_list" >clientAddr</a></td><td>&nbsp; </td></tr>

<tr valign=top><td><a href="#entitiesEnabled" class="attribute_list" >entitiesEnabled</a></td><td>&nbsp; </td></tr>

<tr valign=top><td><a href="#hasClient" class="attribute_list" >hasClient</a></td><td>&nbsp; </td></tr>

<tr valign=top><td><a href="#roundTripTime" class="attribute_list" >roundTripTime</a></td><td>&nbsp; </td></tr>

<tr valign=top><td><a href="#timeSinceHeardFromClient" class="attribute_list" >timeSinceHeardFromClient</a></td><td>&nbsp; </td></tr>

</table>

<hr>
<a name="detailed_description"></a><h2>详细描述</h2>
<a href="Proxy.html">Proxy</a>是<a href="Base.html">Base</a>的一个特殊类型，它继承自Base，它有一个关联的客户端。本身来说，
它就是一个代理客户端的实体，操控所有服务端向客户端的更新。不能在脚本直接创建<a href="Proxy.html">Proxy</a>类对象。

<hr>
<h2>成员函数文档</h2>

<a name="getClientType"></a><p class="function_definition">
<span class="function_definition">def getClientType( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
这个函数返回客户端类型。
</div>

<p>
<span class="function_return">返回:</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>
UNKNOWN_CLIENT_COMPONENT_TYPE	= 0,<br/>
CLIENT_TYPE_MOBILE				= 1,	// 手机类<br/>
CLIENT_TYPE_PC					= 2,	// pc， 一般都是exe客户端<br/>
CLIENT_TYPE_BROWSER				= 3,	// web应用， html5，flash<br/>
CLIENT_TYPE_BOTS				= 4,	// bots<br/>
CLIENT_TYPE_END					= 5		// end<br/>
</td></tr>
</table>
</p>

<a name="giveClientTo"></a><p class="function_definition">
<span class="function_definition">def giveClientTo( <i>self, proxy</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
将客户端的控制器转交给另一个Proxy，当前的Proxy必须有一个客户端而目标Proxy则必须没有关联客户端，否则将会提示错误。
</div>

<p>
<span class="function_links"><b>参看：</b></span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td><a href="Proxy.html">Proxy</a>.<a href="Proxy.html#onGiveClientToFailure">onGiveClientToFailure</a><br></td></tr>
</table>
</p>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>proxy</i></span></td><td><span class="function_parameter_description">
控制权将转交给这个实体。
</span></td></tr>

</table>
</p>

<a name="streamFileToClient"></a><p class="function_definition">
<span class="function_definition">def streamFileToClient( <i>self, resourceName, desc="", id=-1</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
这个函数类似于<a href="Proxy.html#streamStringToClient">streamStringToClient()</a>，将一个资源文件发送给客户端。发送过程在不同的线程上操作，因此不会危及主线程。
</div>

<p>
<span class="function_links"><b>参看：</b></span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td><a href="Proxy.html">Proxy</a>.<a href="Proxy.html#onStreamComplete">onStreamComplete</a><br></td></tr>
</table>
</p>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>resourceName</i></span></td><td><span class="function_parameter_description">
要发送的资源名称，包含路径。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>desc</i></span></td><td><span class="function_parameter_description">
一个可选的字符串，发送给客户端的资源描述。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>id</i></span></td><td><span class="function_parameter_description">
一个16位的id，它的值完全取决于调用者。如果传入-1系统将会在队列里面选择一个没有在用的id。可以在客户端根据这个id做资源判断。
</span></td></tr>

</table>
</p>

<p>
<span class="function_return">返回：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>
与这个下载关联的id。
</td></tr>
</table>
</p>

<a name="streamStringToClient"></a><p class="function_definition">
<span class="function_definition">def streamStringToClient( <i>self, data, desc="", id=-1</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
发送一些数据到当前实体绑定的客户端。如果客户端端口则数据被清除，
当客户端再次绑定到实体的时候才可调用这个函数。16位的id完全取决于调用者。
<br>
如果调用者没有指定这个ID则系统会分配一个未用过的id。可以在客户端根据这个id做资源判断。
<br><br>
你可以在Proxy的派生类中定义回调函数（onStreamComplete），所有数据成功发送给客户端时或下载失败时会调用这个回调函数。
<br><br>
参看：<a href="Proxy.html">Proxy</a>.<a href=Proxy.html#onStreamComplete>onStreamComplete</a>与客户端实体<a href=../../client/classes/Entity.html>Entity</a>.<a href=../../client/classes/Entity.html#onStreamDataStarted>onStreamDataStarted</a>和
<a href=../../client/classes/Entity.html>Entity</a>.<a href=../../client/classes/Entity.html#onStreamDataRecv>onStreamDataRecv</a>还有<a href=../../client/classes/Entity.html>Entity</a>.<a href=../../client/classes/Entity.html#onStreamDataCompleted>onStreamDataCompleted</a>。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>data</i></span></td><td><span class="function_parameter_description">
要发送的字符串。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>desc</i></span></td><td><span class="function_parameter_description">
一个可选的字符串，发送给客户端的描述。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>id</i></span></td><td><span class="function_parameter_description">
一个16位的id，它的值完全取决于调用者。如果传入-1系统将会在队列里面选择一个没有在用的id。
</span></td></tr>

</table>
</p>

<p>
<span class="function_return">返回：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>
与这个下载关联的id。
</td></tr>
</table>
</p>

<hr>
<h2>回调函数文档</h2>


<a name="onClientDeath"></a><p class="function_definition">
<span class="function_definition">def onClientDeath( <i>self</i> ):</span>
</p>

<div class="function_description">如果在脚本中实现了此回调，这个方法将在客户端断开连接时被调用。 这个方法没有参数。
</div>

<a name="onClientGetCell"></a><p class="function_definition">
<span class="function_definition">def onClientGetCell( <i>self</i> ):</span>
</p>

<div class="function_description">如果在脚本中实现了此回调，当客户端能够调用实体的<a href=../../keywords.html#cell>cell</a>属性时，该回调被调用。
</div>

<a name="onEntitiesEnabled"></a><p class="function_definition">
<span class="function_definition">def onEntitiesEnabled( <i>self</i> ):</span>
</p>

<div class="function_description">如果在脚本中实现了此回调，当实体可用时（ 各种初始化完毕并且可以与客户端通讯 ）该回调被调用。 这个方法没有参数。
</div>

<a name="onGiveClientToFailure"></a><p class="function_definition">
<span class="function_definition">def onGiveClientToFailure( <i>self</i> ):</span>
</p>

<div class="function_description">
如果在脚本中实现了此回调，当实体调用<a href=#onStreamComplete>giveClientTo</a>失败时，该回调被调用。这个方法没有参数。
</div>


<a name="onLogOnAttempt"></a><p class="function_definition">
<span class="function_definition">def onLogOnAttempt( <i>self, ip, port, password</i> ):</span>
</p>

<div class="function_description">如果在脚本中实现了此回调，这个函数在客户端尝试使用当前账号实体进行登录时触发回调。<br>
这种情况通常是实体存在于内存中处于有效状态，最明显的例子是用户A使用此账号登录了，用户B使用同一账号进行登录，此时回调触发。
<br><br>
这个回调函数可以返回如下常量值：<br> 
<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#LOG_ON_ACCEPT>LOG_ON_ACCEPT</a>：允许新的客户端与实体进行绑定，如果实体已经绑定了一个客户端，之前的客户端将被踢出。<br>
<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#LOG_ON_REJECT>LOG_ON_REJECT</a>：拒绝新的客户端与实体绑定。 
<br><a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#LOG_ON_WAIT_FOR_DESTROY>LOG_ON_WAIT_FOR_DESTROY</a>：等待实体销毁后再进行客户端绑定。
<br><br>
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>ip</i></span></td><td><span class="function_parameter_description">&nbsp;尝试登录的客户端IP地址。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>port</i></span></td><td><span class="function_parameter_description">&nbsp;尝试登录的客户端连接的端口。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>password</i></span></td><td><span class="function_parameter_description">&nbsp;用户登录时使用的MD5密码。
</span></td></tr>

</table>
</p>

<a name="onStreamComplete"></a><p class="function_definition">
<span class="function_definition">def onStreamComplete( <i>self, id, success</i> ):</span>
</p>

<div class="function_description">如果在脚本中实现了此回调，当用户使用<a href="Proxy.html">Proxy</a>.<a href=Proxy.html#streamStringToClient>streamStringToClient</a>()或<a href="Proxy.html">Proxy</a>.<a href=Proxy.html#streamFileToClient>streamFileToClient</a>()完成时，该回调被调用。


</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>id</i></span></td><td><span class="function_parameter_description">&nbsp;与下载关联的id。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>success</i></span></td><td><span class="function_parameter_description">&nbsp;成功与否。
</span></td></tr>

</table>
</p>

<hr>
<h2>属性文档</h2>

<a name="__ACCOUNT_NAME__"></a><p class="attribute_definition">
<span class="attribute_definition">__ACCOUNT_NAME__</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
如果proxy是帐号则可以访问__ACCOUNT_NAME__得到帐号名。
</div>

<a name="__ACCOUNT_PASSWORD__"></a><p class="attribute_definition">
<span class="attribute_definition">__ACCOUNT_PASSWORD__</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
如果proxy是帐号则可以访问__ACCOUNT_PASSWORD__得到帐号MD5密码。
</div>

<a name="clientAddr"></a><p class="attribute_definition">
<span class="attribute_definition">clientAddr</span>
</p>

<div class="attribute_description">This tuple contains the ip and port of the Client machine
</div>

<a name="entitiesEnabled"></a><p class="attribute_definition">
<span class="attribute_definition">entitiesEnabled</span>
</p>

<div class="attribute_description">This is whether or not entities have been enabled by the Client.
Scripts cannot communicate with the Client until it enables entities.
</div>

<a name="hasClient"></a><p class="attribute_definition">
<span class="attribute_definition">hasClient</span>
</p>

<div class="attribute_description">This is whether or not a client is currently attached to this <a href="Proxy.html">Proxy</a>.
</div>

<a name="latencyLast"></a><p class="attribute_definition">
<span class="attribute_definition">latencyLast</span>
</p>

<div class="attribute_description">This is the latency value that was used for the last check of the
latency triggers. It may be useful for initialising the state of
trigger call handlers when inserting their trigger value into the list.
</div>

<a name="latencyTriggers"></a><p class="attribute_definition">
<span class="attribute_definition">latencyTriggers</span>
</p>

<div class="attribute_description">This is a sequence of latency trigger values. Whenever the latency
passes this value in either direction, the onLatencyTrigger method
is called. The call is made with the relevant trigger value and
the direction (1 = above, 0 = below) as arguments. The latency is
checked roughly every second, but the calls occur in sorted order,
as if the latency value moved smoothly through its range. The latency
value used for this calculation is that of 'timeSinceHeardFromClient'.
</div>

<a name="roundTripTime"></a><p class="attribute_definition">
<span class="attribute_definition">roundTripTime</span>
</p>

<div class="attribute_description">This is the average round trip time in seconds for communication to the
client.
</div>

<a name="timeSinceHeardFromClient"></a><p class="attribute_definition">
<span class="attribute_definition">timeSinceHeardFromClient</span>
</p>

<div class="attribute_description">This is the number of seconds since a packet from the client was last
received.
</div>

<a name="wards"></a><p class="attribute_definition">
<span class="attribute_definition">wards</span>
</p>

<div class="attribute_description">This is a list of EntityIDs that the associated Client is allowed to control.  When controlEntity()
is called on the Client, the newly controlled Entity should be added to this list so the updates will
be propagated to the Cell, rather than the Cell updating the Client.
</div>

<hr>
<p class="copyrightFooter">版权归KBEngine所有。</p>
</body>
</html>
